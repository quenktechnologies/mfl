{"version":3,"sources":["../src/lib.js"],"names":[],"mappings":";;;;;QA8FgB;QAoBA;;AAlHhB;;AAIA,SAAS,UAAT,CAAoB,KAApB,EAA2B,MAA3B,EAAmC,KAAnC,EAA0C;;AAEtC,QAAI,SAAS,OAAO,MAAP,CAAc,IAAd,CAAT,CAFkC;;AAItC,YAAQ,MAAR;;AAEI,aAAK,GAAL;AACI,mBAAO,KAAP,IAAgB,KAAhB,CADJ;AAEI,kBAFJ;;AAFJ,aAMS,GAAL;AACI,mBAAO,KAAP,IAAgB;AACZ,qBAAK,KAAL;aADJ,CADJ;AAII,kBAJJ;;AANJ,aAYS,IAAL;AACI,mBAAO,KAAP,IAAgB;AACZ,sBAAM,KAAN;aADJ,CADJ;AAII,kBAJJ;;AAZJ,aAkBS,GAAL;AACI,mBAAO,KAAP,IAAgB;AACZ,qBAAK,KAAL;aADJ,CADJ;AAII,kBAJJ;;AAlBJ,aAwBS,IAAL;AACI,mBAAO,KAAP,IAAgB;AACZ,sBAAM,KAAN;aADJ,CADJ;AAII,kBAJJ;;AAxBJ,aA8BS,KAAL;AACI,mBAAO,KAAP,IAAgB;AACZ,qBAAK,KAAL;aADJ,CADJ;AAII,kBAJJ;;AA9BJ,aAoCS,GAAL;AACI,mBAAO,KAAP,IAAgB,EAAC,QAAO,MAAM,OAAN,CAAc,qBAAd,EAAqC,MAArC,CAAP,EAAjB,CADJ;AAEI,kBAFJ;AApCJ;AAwCQ,kBADJ;;AAvCJ,KAJsC;AA+CtC,WAAO,MAAP,CA/CsC;CAA1C;;;;;;AAuDA,SAAS,iBAAT,CAA2B,IAA3B,EAAiC,GAAjC,EAAsC;;AAElC,WAAO,KAAK,GAAL,CAAS,kBAAU;;AAEtB,YAAI,CAAC,IAAI,cAAJ,CAAmB,OAAO,KAAP,CAApB,EACA,OAAO,IAAP,CADJ;;AAGA,eAAO,WAAW,OAAO,KAAP,EAAc,OAAO,QAAP,EAC5B,OAAQ,IAAI,OAAO,KAAP,CAAX,KAA6B,UAA7B,GACD,IAAI,OAAO,KAAP,CAAJ,CAAkB,OAAO,KAAP,CADlB,GACkC,OAAO,KAAP,CAFtC,CALsB;KAAV,CAAT,CASJ,MATI,CASG;eAAU;KAAV,CATV,CAFkC;CAAtC;;;;;;;;;;;;;;;;;;;;;;AAmCO,SAAS,OAAT,CAAiB,GAAjB,EAAsB,GAAtB,EAA2B;;AAE9B,QAAI,IAAI,OAAO,MAAP,CAAc,IAAd,CAAJ,CAF0B;;AAI9B,QAAI,IAAI,OAAJ,CAAY,GAAZ,CAAgB,MAAhB,GAAyB,CAAzB,EACA,EAAE,IAAF,GAAS,kBAAkB,IAAI,OAAJ,CAAY,GAAZ,EAAiB,GAAnC,CAAT,CADJ;;AAGA,QAAI,IAAI,OAAJ,CAAY,EAAZ,CAAe,MAAf,GAAwB,CAAxB,EACA,EAAE,GAAF,GAAQ,kBAAkB,IAAI,OAAJ,CAAY,EAAZ,EAAgB,GAAlC,CAAR,CADJ;;AAGA,WAAO,CAAP,CAV8B;CAA3B;;;;;;;;AAoBA,SAAS,KAAT,CAAe,MAAf,EAAuB;AAC1B,WAAO,eAAO,KAAP,CAAa,MAAb,CAAP,CAD0B;CAAvB","file":"lib.js","sourcesContent":["import {\n    parser\n} from './parser';\n\nfunction get_clause(field, symbol, value) {\n\n    var clause = Object.create(null);\n\n    switch (symbol) {\n\n        case '=':\n            clause[field] = value;\n            break;\n\n        case '>':\n            clause[field] = {\n                $gt: value\n            };\n            break;\n\n        case '>=':\n            clause[field] = {\n                $gte: value\n            };\n            break;\n\n        case '<':\n            clause[field] = {\n                $lt: value\n            };\n            break;\n\n        case '<=':\n            clause[field] = {\n                $lte: value\n            };\n            break;\n\n        case '$in':\n            clause[field] = {\n                $in: value\n            };\n            break;\n\n        case '?':\n            clause[field] = {$regex:value.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\")};\n            break;\n        default:\n            break;\n\n    }\n    return clause;\n\n}\n\n/**\n * filter_conversion filters out the unknown fields before converting them.\n * @return {array}\n */\nfunction filter_conversion(list, map) {\n\n    return list.map(clause => {\n\n        if (!map.hasOwnProperty(clause.field))\n            return null;\n\n        return get_clause(clause.field, clause.operator,\n            (typeof map[clause.field] === 'function') ?\n            map[clause.field](clause.value) : clause.value);\n\n    }).filter(clause => clause);\n\n}\n\n/**\n * convert is a function that takes the AST\n * and turns it into a query. Currently preforms no optimisations\n * so expensive queries are possible. Also this does no\n * real validation of filter criteria, use a map of functions\n * to intercept potentially dangerous values.\n *\n * @todo Perhaps provide a syntax to declare what operators \n * are valid for a particular key? Maybe in the map like so:\n *  ```javascript {\n *       name: {valid_ops:['?', '='], check:x=>}\n *     }\n *  ```\n *\n * Be careful...\n * @param {AST} ast The result of a successful parse call.\n * @param {object} map A map that indicates what are valid fields. \n *                     If the value the value of the map keys are functions\n *                     they will each be called when their field is detected.\n */\nexport function convert(ast, map) {\n\n    var q = Object.create(null);\n\n    if (ast.filters.AND.length > 0)\n        q.$and = filter_conversion(ast.filters.AND, map);\n\n    if (ast.filters.OR.length > 1)\n        q.$or = filter_conversion(ast.filters.OR, map);\n\n    return q;\n\n}\n\n/**\n * parse parses a string into an\n * abstract syntax tree (ast)\n * @param {string} source\n * @returns {object}\n */\nexport function parse(source) {\n    return parser.parse(source);\n}\n"]}